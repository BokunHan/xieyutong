---
description: uniCloud数据库设计规范，包含Schema结构定义、外键关联、权限控制,索引设计,用户表相关设计等关键指南，确保云开发中数据库结构的简洁性、安全性和可维护性。所有DB Schema必须严格遵循。
globs: 
alwaysApply: false
---

# uniCloud 数据库设计规范


## 核心原则

1. **奥卡姆剃刀原则**:

   * 严格遵循"如无必要，勿增实体"的原则。仅定义业务必要表和字段，避免过度设计和不必要的复杂性。
2. **可维护性**:

   * Schema 定义必须清晰易懂
   * 所有 `description` 字段必须使用中文准确描述其用途。
3. **安全性**:

   * 通过 `permission` 字段设置不同角色的读写权限。

## Schema 结构与字段定义

每张表/集合，都有一个表名.schema.json的文件，来描述表的信息、字段的信息。

一个表的简单schema.json示例如下

```
{
	"bsonType": "object", // 固定节点
	"description": "该表的描述",
	"required": [], // 必填字段列表
	"properties": { // 该表的字段清单
		"_id": { // 字段名称，每个表都会带有_id字段
			"description": "ID，系统自动生成"
			// 这里还有很多字段属性可以设置
		},
		"field2": { // 字段2，每个表都会带有_id字段
			"description": ""
			// 这里还有很多字段属性可以设置
		}
	}
}
```

### 0. 命名规范

1. **数据库表名**:
*uni云开发自带的表，沿用其原有名字，如(用户管理相关的uni-id-users,uni-id-roles,uni-id-permissions,opendb-verify-codes)。
   * 新增的表，必须采用全小写，单词间用中划线 `-` 连接，并以 `a-` 作为统一前缀
   * 示例:`a-text-segments`, `a-order-details`。
2. **字段名**:
   * 必须使用蛇形命名法 ，比如 `user_id`, `order_status`, `created_at`

### 1. 表级别定义 (顶层结构)

* **`bsonType`**: 固定为 `"object"`。
* **`description`**: **(必需)** 对该表的整体功能和用途进行中文描述。
* **`required`**: (可选) 数组类型，列出该表下所有必填的一级字段名。
* **`permission`**: **(关键)** 定义表级别的操作权限。务必根据业务需求，为不同角色（如管理员、登录用户、匿名用户）配置精细的读写权限。
  * 示例（仅管理员可写，登录用户可读自己的数据，其他不可读）：
    ```json
    "permission": {
      "read": "doc.user_id == auth.uid || role  in ['admin']",
      "create": "role in ['admin']",
      "update": "role in ['admin'] && doc.user_id == auth.uid", // 管理员也只能更新自己的记录
      "delete": "role in ['admin']"
    }
    ```
* **`properties`**: **(必需)** 对象类型，包含该表所有字段的详细定义。

### 2. 字段级别定义 (`properties` 内的每个字段)

对于 `properties` 中的每一个字段，应至少包含以下核心属性：

* **`bsonType`**: **(必需)** 准确指定字段的数据类型 (如 `string`, `number`, `boolean`, `object`, `array`, `date`, `timestamp`, `file` 等)。
  * 若 `bsonType` 为 `array`，建议使用 `arrayType` 指定数组成员类型 (HBuilderX 3.1.0+)。
* **`description`**: **(必需)** 对该字段的用途、含义或业务规则进行清晰的中文描述。
* title: **(必需)** 该字段的名字。

#### 字段值域与格式校验

* **`required`**: (可选，但推荐明确) 布尔值，`true` 表示该字段必填。也可在表级 `required` 数组中声明。
* **`defaultValue`**: (可选) 字段的默认值。
* **`forceDefaultValue`**: (可选) 强制默认值，客户端不可修改。常用于 `create_time`, `user_id` (通过 `auth.uid`) 等系统控制字段。

  * 示例 (创建时间): `{ "$env": "now" }`
  * 示例 (当前用户ID): `{ "$env": "uid" }`
* **`enum`**: (可选) 数组，定义字段的枚举值范围。

  * 如性别字段，合法值域只能是"0"、"1"、"2"中的一个。
    `"enum": [0,1,2] `
* **`format`**: (可选) 对于特定格式的字符串，如 `'url'`, `'email'`。
* **`pattern`**: (可选) 使用正则表达式对字符串字段进行校验。

  * 示例 (中国大陆手机号): `"^1[3-9]\\d{9}$"`
* **`minLength` / `maxLength`**: (可选) 限制字符串或数组的最小/最大长度。
* **`minimum` / `maximum`**: (可选) 限制数字类型的最小/最大值。

  * 可配合 `exclusiveMinimum` / `exclusiveMaximum` (布尔值)排除边界值。
* **`trim`**: (可选) 字符串去空格，可选值为 `none` | `both` | `start` | `end`。
* **`fileMediaType`**: (可选, `bsonType: "file"` 时) 文件类型，如 `all` | `image` | `video`。
* **`fileExtName`**: (可选, `bsonType: "file"` 时) 允许的文件扩展名，逗号分隔，如 `"jpg,png,gif"`。

#### 关联关系

* **`foreignKey`**: (可选) 定义外键关联。格式为 `表名.字段名`。
  * 示例: `uni-id-users._id` (关联到用户表的 `_id` 字段)。
  * 清晰定义外键关系能极大简化 JQL 联表查询。
* **`parentKey`**: (可选) 定义同一数据表内的父子级关系字段名，用于树状数据查询。

#### 错误与校验函数

* **`errorMessage`**: (可选) 对象或字符串，自定义校验失败时的错误提示信息。可以为不同校验规则（如 `required`, `pattern` 等）指定不同消息。
  * ```json
    "errorMessage": {
      "required": "该字段为必填项",
      "pattern": "请输入有效的手机号码"
    }
    ```

## 权限系统 `permission` 详解

### 1. 权限系统概述

**DB Schema 的权限系统**是为 JQL 设计的安全机制，尤其对于 ClientDB 操作至关重要：

* **核心作用**：保障前端直接操作数据库的安全性，无需编写后端权限代码
* **原理**：定义规则指定"谁"可以对"哪些数据"进行"什么操作"
* **规则组成**：对数据的指定 + 对角色的指定

> **重要提示**：超级管理员（`admin` 角色）默认不受权限限制，拥有所有数据的完全访问权限。

### 2. 权限配置层级

#### 表级权限控制

表级权限控制整个集合的增删改查和计数操作：

```json
"permission": {
  "read": true,                      // 所有人可读
  "create": "auth.uid != null",      // 登录用户可创建
  "update": "doc.user_id == auth.uid", // 只能更新自己的数据
  "delete": "doc.user_id == auth.uid && 'admin' in auth.role", // 只有管理员可删除自己的数据
  "count": true                      // 所有人可统计数量
}
```

> **注意**：从 HBuilderX 3.1.0 开始支持 `count` 权限。所有默认值均为 `false`。

#### 字段级权限控制

字段级权限控制特定字段的读写：

```json
"age": {
  "bsonType": "number",
  "permission": {
    "read": true,              // 所有人可读取 age 字段
    "write": "doc._id == auth.uid" // 只能修改自己的 age 字段
  }
}
```

> **特别说明**：
>
> * 子级权限继承父级权限，需同时满足表级+字段级权限
> * `bsonType` 为 `password` 的字段，ClientDB 完全不可操作（包括 admin 用户）

### 3. 条件筛选与数据集权限

可以通过表达式限定只允许操作满足特定条件的数据：

```json
"permission": {
  "read": "doc.status == true",  // 只能读取 status 为 true 的记录
  "update": "doc.user_id == auth.uid && doc.status == true" // 只能更新自己且状态为 true 的记录
}
```

这种设计可以：

* 限制用户只能查询/操作符合条件的数据子集
* 实现精细的数据权限控制，如用户只能操作自己创建的数据

### 4. 权限规则中的变量与运算符

#### 可用变量

| 变量                | 说明                   |
| ------------------- | ---------------------- |
| `auth.uid`        | 当前登录用户ID         |
| `auth.role`       | 当前用户角色数组       |
| `auth.permission` | 当前用户权限数组       |
| `doc`             | 要操作的目标数据记录   |
| `now`             | 当前服务器时间戳(毫秒) |

#### 常用运算符

* 比较运算符：`==`, `!=`, `>`, `>=`, `<`, `<=`
* 逻辑运算符：`&&`, `||`, `!`
* 成员运算符：`in`（判断元素是否在数组中）

#### 示例

```json
// 用户只能修改自己30天内创建的文章
"update": "doc.user_id == auth.uid && doc.create_time > now - 2592000000"

// 只有拥有 edit_post 权限的用户可删除文章
"delete": "'edit_post' in auth.permission"

// 用户可以查看自己的文章或公开的文章
"read": "doc.is_public || doc.user_id == auth.uid"
```

### 5. 跨表查询权限验证

有时候权限校验需要查询其他表的数据，可通过 `get` 方法实现：

```json
// 只有积分大于100的用户才能创建文章
"create": "get(`database.uni-id-users.${auth.uid}`).score > 100"

// 只有帖子所属板块的版主才能编辑帖子
"update": "get(`database.forums.${doc.forum_id}`).moderator_id == auth.uid"
```

> **注意**：`get` 方法参数必须是唯一确定值，不支持范围查询或模糊查询。

### 6. 权限规划与最佳实践

* **区分角色与权限**：`role` 是角色身份，`permission` 是具体权限点
* **权限设计分层**：表级控制整体访问权限，字段级控制数据敏感度差异化访问
* **结合 `forceDefaultValue`**：敏感字段如 `user_id`、`create_time` 宜用 `forceDefaultValue` 自动设置
* **权限错误排查**：
  * 检查 Schema 是否已上传到云端
  * 是否尝试在客户端访问 `password` 类型字段
  * 检查数据操作是否满足配置的权限条件
  * 确认是否使用了 JQL 查询（非 JQL 不走权限校验）

## `foreignKey` 字段外键（数据关联核心）

### 1. 为何需要分表与 `foreignKey`

虽然 MongoDB 支持深层嵌套文档，但在实际业务中推荐分表设计：

* **避免过度嵌套**: 在复杂业务场景（如用户、文章、评论关系）中，过度嵌套会导致：

  * **查询性能低下**：嵌套层级深、数据量大时，查询效率显著下降。
  * **查询复杂度高**：某些特定查询（如独立搜索文章、对评论分页）变得困难。
  * **数据冗余**：难以维护清晰、一致的数据结构。
* **适合嵌套的场景**：只有当满足"不会被单独查询"且"记录条数较少"的情况，如用户简历中的工作经历。
* **正确的分表示例**：一个文章系统应该分为：

  * 用户表：`uni-id-users`
  * 文章分类表：`opendb-news-categories`
  * 文章表：`opendb-news-articles`
  * 评论表：`opendb-news-comments`

### 2. `foreignKey` 的使用方法

* **格式**: `被关联的表名.被关联的字段名`（通常是 `_id`）。

  * 示例: 文章表中的 `user_id` 字段，应设置 `"foreignKey": "uni-id-users._id"`。
* **定义位置**: 在"引用方"的字段 Schema 中定义。

  * 即，在文章表的 `user_id` 字段下定义 `foreignKey`，而不是在用户表的 `_id` 字段下。
* **数据存储**: 文章表的 `user_id` 字段存储的是用户表中作者记录的 `_id` 值，而不是存用户名等其他信息。
* **字段冗余设计**: 有时为优化查询性能，可能在表中冗余存储关联表的常用字段（如文章表存储作者昵称），但基础的 `_id` 关联仍必须存在。

### 3. `foreignKey` 的核心价值：JQL 联表查询

配置 `foreignKey` 后，JQL 可以极大简化联表查询：

* **基本联表查询**：获取文章列表并同时查询作者信息

  ```javascript
  const db = uniCloud.database();
  db.collection('a-articles')
    .field('title, content, user_id{username, avatar}') // 注意这里的嵌套语法
    .get()
    .then(res => {
      console.log(res.data);
      // 每篇文章数据会包含作者信息
      // { 
      //   title: "文章标题", 
      //   content: "文章内容",
      //   user_id: [{ username: "作者名" }]
      // }
    })
  ```
* **多层级联表**：获取文章详情并带出分类和作者信息

  ```javascript
  const db = uniCloud.database();
  db.collection('a-articles')
    .doc('文章ID')
    .field('title, content, user_id{username}, category_id{name}')
    .get()
    .then(res => {
      console.log(res.data);
      // {
      //   title: "文章标题",
      //   content: "文章内容",
      //   user_id: [{ username: "作者名" }],
      //   category_id: [{ name: "分类名" }]
      // }
    })
  ```
* **查询文章评论并带出评论者信息**

  ```javascript
  const db = uniCloud.database();
  db.collection('a-comments')
    .where(`article_id == "${文章ID}"`)
    .field('content, create_time, user_id{username, avatar}')
    .get()
    .then(res => {
      console.log(res.data);
      // 评论列表，每条评论包含评论者信息
    })
  ```

### `parentKey` 树形表

用于描述同一表内记录间的父子层级关系，适用于部门、分类等树形数据：

* **与 `foreignKey` 的区别**: `foreignKey` 用于表间关联，`parentKey` 用于表内层级关联。
* **使用方法**: 在"父级ID"字段（如 `parent_id`）中，设置 `"parentKey": "_id"`。
* **数据结构**: 每个节点是表中独立记录，通过 `parent_id` 指向父节点的 `_id`。
* **查询方法**: 配置后可使用 JQL 的 `getTree()` 方法查询树形数据。

## 数据库索引(xxx.index.json文件)

* 对于每个创建的 DB Schema (即 `xxx.schema.json` 文件)，**必须** 相应创建一个 `xxx.index.json` 文件

### 索引的定义与重要性

* **索引是什么**: 索引通过额外占用磁盘空间，提供快速查询记录的方案。查询时先查询索引文件，根据索引指示再去查询真实数据。
* **核心作用**:
  * **提升查询性能**: 在数据量大时，合理设置索引可显著提高查询速度。
  * **确保唯一性**: 可设置唯一索引来控制字段值不重复。

### 何时需要添加索引

* 当查询操作包含以下条件时，应考虑添加索引：

  * 使用 `where`、`match` 条件过滤数据
  * 使用 `orderBy`、`sort` 对结果排序
  * 需要字段值唯一性控制
  * 使用 ClientDB 的 `getTree` 和 `getTreePath`
* **特别提醒**: 缺少索引的表在数据量增大后可能导致查询变慢甚至超时！这是线上常见故障原因。

### 添加索引的方法

#### 方法一：使用 uniCloud Web 控制台

1. 进入 uniCloud 控制台，选择【云数据库】，点击需索引的集合
2. 进入【索引管理】选项卡，点击【添加索引】
3. 配置索引名称、字段、排序方式和是否唯一

#### 方法二：通过 JSON 文件配置(必须要生成该文件)

1. 在项目 `uniCloud/database` 目录下创建 `表名.index.json` 文件
2. 文件内容示例：
   ```json
   [{
     "IndexName": "user_article_", // 索引名称
     "MgoKeySchema": { // 索引规则
         "MgoIndexKeys": [{
             "Name": "user_id", // 索引字段
             "Direction": "1", // 1：升序，-1：降序，2dsphere：地理位置
         },{
             "Name": "article_id", // 第二个索引字段
             "Direction": "1"
         }],
         "MgoIsUnique": false // 索引是否唯一
     }
   }]
   ```

### 索引类型与应用场景

#### 1. 单字段索引

* 对单个字段建立索引，嵌套字段可用"点表示法"（如 `style.color`）
* 可指定升序或降序排序

#### 2. 组合索引（复合索引）

* 一个索引包含多个字段
* **字段顺序非常重要**：只有查询条件使用索引的前缀字段时才能命中
  * 例如：索引为 `{name, age}` 时，查询条件包含 `name` 或 `name+age` 可命中索引
  * 但单独查询 `age` 无法命中该索引

#### 3. 地理位置索引

* 用于地理位置查询（如附近的人），方向值设为 `2dsphere`
* 示例: 对包含 `{ point: new db.Geo.Point(50, 50) }` 的字段建立地理位置索引

### 索引使用注意事项

#### 1. 唯一性索引

* 设置唯一索引后，该字段在整个集合中不能有重复值
* 默认情况下，字段不存在/为null视为相同值，若有多条记录该字段为null，会违反唯一性约束
* 解决方案：设置为稀疏索引（仅阿里云支持）

#### 2. 稀疏索引（仅阿里云支持）

* 适用于字段需要唯一但可能为空的场景
* 例如：用户表中的邮箱、手机号需要唯一但可空时

#### 3. 重要限制

* **字段大小限制**: 索引字段值不能超过1024字节
  * 不要对大段文本（如文章内容）设置索引
  * 英文字母占1字节，中文汉字占2字节
* **正则表达式**: 正则查询无法利用索引提升性能

#### 4. 索引建议

* 在 Schema 的表级 `description` 中记录索引规划，方便团队成员了解
* 为常用查询条件和 `foreignKey` 关联字段添加索引
* 平衡查询性能与写入性能，索引过多会影响写入速度

## 测试数据 (`.init_data.json`)

* 对于每个创建的 DB Schema (即 `xxx.schema.json` 文件)，**必须** 相应创建一个 `xxx.init_data.json` 文件
* 该文件用于存放初始化数据，方便项目启动和测试。
* 数据格式为一个 JSON 数组，数组中的每个对象代表一条记录。
* **注意**: `.init_data.json` 文件内容直接是数据数组，不包含外层的 `{"data": ...}` 包装。

### 时间戳字段处理规范 ⚠️

**重要警告**：在 `.init_data.json` 初始化数据中，**绝对不能** 手动设置具有 `forceDefaultValue` 配置的时间戳字段，否则会导致 **400 错误**！

#### 错误示例（会导致 400 错误）
```json
// ❌ 错误：不要在初始化数据中设置这些字段
[
  {
    "user_id": "6860cd850966cc4ca981787c2c",
    "level": "normal",
    "status": "active",
    "join_date": {"$env": "now"},     // ❌ 错误！
    "created_at": {"$env": "now"},   // ❌ 错误！
    "updated_at": {"$env": "now"}    // ❌ 错误！
  }
]
```

#### 正确示例
```json
// ✅ 正确：省略具有 forceDefaultValue 的字段
[
  {
    "user_id": "6860cd850966cc4ca981787c2c", 
    "level": "normal",
    "status": "active"
    // join_date, created_at, updated_at 会由 schema 自动生成
  }
]
```

#### 规则说明

* **自动生成字段**：当 schema 中字段配置了 `"forceDefaultValue": {"$env": "now"}` 时，该字段会由数据库自动生成
* **云对象中也要注意**：在云对象的 `add()` 和 `update()` 操作中，同样不要手动设置这些字段
* **可手动设置的时间字段**：只有没有 `forceDefaultValue` 配置的时间字段（如 `upgrade_date`）才可以手动设置

#### 常见的自动时间戳字段
```json
// schema 中的自动时间戳字段配置
"created_at": {
  "bsonType": "timestamp",
  "description": "创建时间",
  "forceDefaultValue": {"$env": "now"}  // 自动生成，不可手动设置
},
"updated_at": {
  "bsonType": "timestamp", 
  "description": "更新时间",
  "forceDefaultValue": {"$env": "now"}  // 自动生成，不可手动设置
}
```

### 基本示例
```json
// 示例: a-demo.init_data.json
[
  {
    "_id": "record_001",
    "name": "示例名称1",
    "type": 1
  },
  {
    "_id": "record_002", 
    "name": "示例名称2",
    "type": 2
  }
]
```

## 用户(user)相关表规范

### 用户相关表必须使用 uni-id 模块

**重要规则**：用户相关的表，**必须**使用 uni-id 模块，沿用其写好的表设计，不进行新的表的创建。

uni-id 的所有数据表，都在 opendb 规范中。在 uniCloud web 控制台新建数据表时，可以从 uni-id 的模板分类里找到下面的表，并一键创建这些表。HBuilderX 3.4.11 起新建 DB Schema 也有模板可选择。

### uni-id 核心数据表结构

#### 1. 用户表 (uni-id-users)

存放用户基本信息。

**主要字段**：

* `_id`：用户ID，系统自动生成
* `username`：用户名，不允许重复
* `password`：密码，加密存储
* `nickname`：用户昵称
* `gender`：用户性别：0 未知 1 男性 2 女性
* `role`：用户角色列表，由role_id组成的数组
* `status`：用户状态：0 正常，1 禁用，2 审核中，3 审核拒绝，4 已注销
* `mobile`：手机号码
* `email`：邮箱地址
* `avatar`：头像地址
* `wx_unionid`、`wx_openid`：微信相关标识
* `qq_unionid`、`qq_openid`：QQ相关标识
* `realname_auth`：实名认证信息
* `register_date`：注册时间
* `last_login_date`：最后登录时间

**特别注意**：

* `wx_openid` 和 `qq_openid` 是对象类型，包含多个平台的 openid
* `realNameAuth` 存储实名认证详细信息
* `register_env` 记录注册时的环境信息

**用户表索引使用注意**：

* opendb 内提供的 uni-id-users 表包含完整的索引
* 建议删除未使用的登录方式对应的索引，避免写入性能问题
* 例如：项目只使用微信登录，可以只保留 wx_unionid、wx_openid.mp 相关索引

#### 2. 验证码表 (opendb-verify-codes)

该表适用于所有需要验证码的场景，不仅限于 uni-id 的手机验证码。

**主要字段**：

* `mobile`/`email`：手机号或邮箱(二选一)
* `code`：验证码
* `scene`：验证场景
* `state`：验证状态：0 未验证 1 已验证 2 已作废
* `expired_date`：验证码过期时间

**注意**：uni-id 不会自动删除本表的历史数据，数据保留有效期需要开发者自行管理，可以通过定时云函数清理过期数据。

#### 3. 角色表 (uni-id-roles)

**主要字段**：

* `role_id`：角色唯一标识
* `role_name`：角色名称
* `permission`：角色拥有的权限列表
* `created_date`：角色创建时间

#### 4. 权限表 (uni-id-permissions)

**主要字段**：

* `permission_id`：权限唯一标识
* `permission_name`：权限名称
* `comment`：备注
* `created_date`：权限创建时间

### uni-id 表使用最佳实践

1. **不要修改 uni-id 表的核心字段结构**，避免与 uni-id 模块不兼容
2. **可以向用户表添加自定义字段**，但不要删除或修改现有字段
3. **使用权限系统时**，需要在 uniCloud admin 中创建好权限、角色并分配给用户
4. **注意保持 uni-id 及 uni-id-common 模块的及时更新**
